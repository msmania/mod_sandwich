/* 
**  mod_sandwich.c -- Apache sample sandwich module
**  [Autogenerated via ``apxs -n sandwich -g'']
**
** http://apache.webthing.com/mod_txt/mod_txt.c
** http://www.apachetutor.org/dev/brigades
**
*/ 

#include "httpd.h"
#include "http_config.h"
#include "http_protocol.h"
#include "ap_config.h"

static const char FILTER_NAME[]="SANDWICH";

static void sandwich_register_hooks(apr_pool_t *p);
static void *create_config(apr_pool_t *pool, char *x);
static void *merge_config(apr_pool_t *pool, void *in_base, void *in_add);

#define TEXT_HEAD 0x1
#define TEXT_FOOT 0x2

typedef struct {
    const char *header;
    const char *footer;
} module_config;

typedef struct {
    apr_bucket *head;
    apr_bucket *foot;
    unsigned int state;
} filter_context;

static const command_rec commands_table[] = {
    AP_INIT_TAKE1("Sandwich_Header", ap_set_file_slot, (void*)APR_OFFSETOF(module_config, header), OR_ALL, "Header file"),
    AP_INIT_TAKE1("Sandwich_Footer", ap_set_file_slot, (void*)APR_OFFSETOF(module_config, footer), OR_ALL, "Footer file"),
    {NULL}
};

/* Dispatch list for API hooks */
module AP_MODULE_DECLARE_DATA sandwich_module = {
    STANDARD20_MODULE_STUFF, 
    create_config,           /* create per-dir    config structures */
    merge_config,            /* merge  per-dir    config structures */
    NULL,                    /* create per-server config structures */
    NULL,                    /* merge  per-server config structures */
    commands_table,          /* table of config file commands       */
    sandwich_register_hooks  /* register hooks                      */
};

static void *create_config(apr_pool_t *pool, char *x) {
    return apr_pcalloc(pool, sizeof(module_config));
}

static void *merge_config(apr_pool_t *pool, void *in_base, void *in_add) {
    module_config *base = (module_config*)in_base;
    module_config *add = (module_config*)in_add;

    module_config *config = apr_palloc(pool, sizeof(module_config));
    config->header = add->header ? add->header : base->header;
    config->footer = add->footer ? add->footer : base->footer;

    return config;
}

static apr_bucket *text_file_bucket(request_rec *r, const char *fname) {
    apr_file_t *file = NULL;
    apr_finfo_t finfo;

    if ( apr_stat(&finfo, fname, APR_FINFO_SIZE, r->pool)!=APR_SUCCESS ) {
        return NULL;
    }

    if ( apr_file_open(&file, fname, APR_READ|APR_SHARELOCK|APR_SENDFILE_ENABLED, APR_OS_DEFAULT, r->pool)!=APR_SUCCESS ) {
        return NULL;
    }

    if ( !file ) {
        return NULL;
    }

    return apr_bucket_file_create(file, 0, finfo.size, r->pool, r->connection->bucket_alloc);
}

static apr_bucket *text_escape(char c, apr_bucket_alloc_t *alloc) {
    switch ( c ) {
    case '<': return apr_bucket_transient_create("&lt;", 4, alloc);
    case '>': return apr_bucket_transient_create("&gt;", 4, alloc);
    case '&': return apr_bucket_transient_create("&amp;", 5, alloc);
    case '"': return apr_bucket_transient_create("&quot;", 6, alloc);
    case ' ': return apr_bucket_transient_create("&nbsp;", 6, alloc);
    default: return NULL;
    }
}

static void *init_context(ap_filter_t *f) {
    if ( !f->ctx ) {
        filter_context *context = f->ctx = apr_palloc(f->r->pool, sizeof(filter_context));
        module_config *config = ap_get_module_config(f->r->per_dir_config, &sandwich_module); 

        context->head = text_file_bucket(f->r, config->header);
        context->foot = text_file_bucket(f->r, config->footer);
    }

    return f->ctx;
}


static apr_status_t sandwich_filter_handler(ap_filter_t *filter, apr_bucket_brigade *bb) {
    apr_bucket *b = NULL;
    filter_context *context = (filter_context*)filter->ctx;

    if ( context==NULL ) {
        context = init_context(filter);
        apr_table_unset(filter->r->headers_out, "Content-Length");
    }

    for ( b = APR_BRIGADE_FIRST(bb);
          b != APR_BRIGADE_SENTINEL(bb);
          b = APR_BUCKET_NEXT(b) ) {
        if ( APR_BUCKET_IS_EOS(b) ) {
            if ( context->foot && !(context->state & TEXT_FOOT) ) {
                context->state |= TEXT_FOOT;
                APR_BUCKET_INSERT_BEFORE(b, context->foot);
            }
        }
        else if ( APR_BUCKET_IS_FLUSH(b) ) {
        }
        else if ( APR_BUCKET_IS_METADATA(b) ) {
        }
        else {
            const char *buf = NULL;
            size_t bytes = 0;
            if ( apr_bucket_read(b, &buf, &bytes, APR_BLOCK_READ)==APR_SUCCESS ) {
                size_t count = 0;
                const char *p = buf;

                while ( count < bytes ) {
                    size_t sz = strcspn(p, "<>&\" ");
                    count += sz;

                    if ( count < bytes ) {
                        apr_bucket_split(b, sz);
                        b = APR_BUCKET_NEXT(b);
                        APR_BUCKET_INSERT_BEFORE(b, text_escape(p[sz], filter->r->connection->bucket_alloc));

                        apr_bucket_split(b, 1);
                        APR_BUCKET_REMOVE(b);
                        b = APR_BUCKET_NEXT(b);

                        count += 1;
                        p += (sz + 1);
                    }
                }
            }
        }
    }

    if ( context->head && !(context->state & TEXT_HEAD) ) {
        context->state |= TEXT_HEAD;
        APR_BRIGADE_INSERT_HEAD(bb, context->head);
    }

    return ap_pass_brigade(filter->next, bb);
}

static void sandwich_register_hooks(apr_pool_t *p)
{
    // It's ok to use the 3rd parameter for init_context, but ap_init_context_func cannot be used
    // to update the value of Content-Length from. Content-Length should be updated from the
    // first call of handler. This means that we need to check the context is NULL or not
    // before the main loop in handler.  In this case, it's simpler to call init_context from
    // handler directly and not to use ap_init_context_func here.
    ap_register_output_filter(FILTER_NAME, sandwich_filter_handler, NULL, AP_FTYPE_RESOURCE);
}

